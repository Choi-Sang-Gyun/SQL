--집합 연산자
--UNION - 합집합(중복X)
--UNION ALL - 합집합(중복O)
--INTERSECT - 교집합
--MINUS - 차집합

--컬럼 개수가 일치해야 집합연산자 사용이 가능합니다
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION 
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--UNION ALL은 중복 데이터도 같이 찍어준다
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;

--MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
-----
SELECT 'PARK', 200 FROM DUAL
UNION ALL
SELECT 'KIM', 300 FROM DUAL
UNION ALL
SELECT 'CHOI', 400 FROM DUAL;

---------------------------------------------------------------------
--시험의 단골문제
--분석함수
SELECT FIRST_NAME,
       SALARY,
       RANK()OVER(ORDER BY SALARY DESC)AS 중복등수,
       DENSE_RANK() OVER(ORDER BY SALARY DESC)AS 중복없는등수,
       ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 일련번호,
       ROWNUM --정렬이 되면 순서가 바뀜
FROM EMPLOYEES;

--그룹함수 -행에 대한 기초통계값
--SUM, AVG, MIN, COUNT --전부 NULL이 아닌 데이터에 대해서 통계를 구합니다

SELECT SUM(SALARY), AVG(SALARY), MAX(SALARY), MIN(SALARY), COUNT(SALARY) FROM EMPLOYEES;

--MIN, MAX 날짜, 문자열에도 적용됩니다
SELECT MIN(HIRE_DATE), MAX(HIRE_DATE), MIN(FIRST_NAME), MAX(FIRST_NAME) FROM EMPLOYEES;

--COUNT 함수는 2가지 사용방법이 있음
SELECT COUNT(COMMISSION_PCT) FROM EMPLOYEES; --35 (NULL이 아닌 데이터에 대해서 집계)
SELECT COUNT(*) FROM EMPLOYEES; --107 (NULL 포함 전체 행 수)

--주의할 점, 그룹함수는 일반 컬럼과 동시에 사용이 불가능
SELECT FIRST_NAME, AVG(SALARY) FROM EMPLOYEES; -- X
--그룹함수 뒤에 OVER()를 붙이면 전체행이 출력이 되고, 그룹함수 사용이 가능함
SELECT FIRST_NAME, AVG(SALARY) OVER(), COUNT(*) OVER() FROM EMPLOYEES;

------------------------------------------------------------
--GROUP BY 절 - 컬럼 기준으로 그룹핑
SELECT DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, SUM(SALARY), AVG(SALARY), MIN(SALARY), MAX(SALARY), COUNT(*)
FROM EMPLOYEES GROUP BY DEPARTMENT_ID;
--주의할 점 - GROUP BY 에 지정되지 않은 컬럼은 SELECT절에 사용할 수 없음

SELECT DEPARTMENT_ID,
FIRST_NAME --X
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;
--2개 이상의 그룹화
SELECT DEPARTMENT_ID, JOB_ID
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;

--COUNT(*) OVER() 총 행의 수를 출력할 수도 있음
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) OVER() AS 전체행수
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID;
--WHERE절에 그룹의 조건을 넣는 것이 아닙니다
SELECT DEPARTMENT_ID, SUM(SALARY)
FROM EMPLOYEES
WHERE SUM(SALARY) > = 5000 -- GROUP BY조건을 쓰는 곳은 HAVING이라고 있음
GROUP BY DEPARTMENT_ID;
-------------------------------------------------------------
--HAVING - GROUP BY의 조건
--WHERE - 일반 행의 조건
SELECT DEPARTMENT_ID, AVG(SALARY), COUNT(*)
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING AVG(SALARY) >= 5000 AND COUNT(*) >= 1;

--각 직무별 샐러리~들의 급여 평균
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE JOB_ID LIKE 'SA%'
GROUP BY JOB_ID;

--각 직무별 샐러리~들의 급여 평균이 10000이 넘는 경우
SELECT JOB_ID, AVG(SALARY)
FROM EMPLOYEES
WHERE JOB_ID LIKE 'SA%'
GROUP BY JOB_ID
HAVING AVG(SALARY) >= 10000
ORDER BY AVG(SALARY) DESC;
------------------------------------------------------------
--시험 대비
--ROLLUP -GROUP BY와 함께 사용되고, 상위그룹의 소계를 구합니다
SELECT DEPARTMENT_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID);
--
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID, JOB_ID;
--CUBE - 롤업에 의해서 구해진 값 + 서브 그룹의 통계가 추가됨
SELECT DEPARTMENT_ID, JOB_ID, AVG(SALARY)
FROM EMPLOYEES
GROUP BY CUBE(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID, JOB_ID;

--GROUPING() - 그룹절로 만들어진 경우에는 0을 반환, 롤업 OR 큐브로 만들어진 행인 경우에는 1을 반환
SELECT DECODE(GROUPING(DEPARTMENT_ID), 1, '총계, DEPARTMENT_ID) AS DEPARTMENT_ID,
       DECODE(GROUPING(JOB_ID),1, '소계', JOB_ID) AS JOB_ID,
       AVG(SALARY), GROUPING(DEPARTMENT_ID), GROUPING(JOB_ID)
FROM EMPLOYEES
GROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)
ORDER BY DEPARTMENT_ID;









